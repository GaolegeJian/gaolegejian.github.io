<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GaoJian&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-05T13:56:39.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gao Jian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java异常机制(Exception)</title>
    <link href="http://yoursite.com/2017/06/05/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6-Exception/"/>
    <id>http://yoursite.com/2017/06/05/Java异常机制-Exception/</id>
    <published>2017-06-05T08:04:18.000Z</published>
    <updated>2017-06-05T13:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>软件程序在运行过程中，非常可能遇到异常问题，我们叫异常，英文是：Exception，意思是例外。这些例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃。<br>常见的异常：</p>
<ul>
<li>用户输入错误</li>
<li>设备错误</li>
<li>硬件问题，比如打印机关掉、服务器问题</li>
<li>磁盘满了</li>
<li>……等等<h3 id="异常（Exception）的概念"><a href="#异常（Exception）的概念" class="headerlink" title="异常（Exception）的概念"></a>异常（Exception）的概念</h3>Java异常是Java提供的用于处理程序中错误的一种机制。<br>  public static void main(String[] args) {<pre><code>int i = 1/0;
</code></pre>  }<br>  Exception in thread “main” java.lang.ArithmeticException: / by zero<pre><code>at fileclass.TestFile.main(TestFile.java:36)
</code></pre><strong>Java是采用面向对象的方式来处理异常的，处理过程：</strong></li>
<li><strong>抛出异常：</strong>在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE</li>
<li><strong>捕获异常：</strong>JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回朔，直到找到相应的异常处理代码为止。<h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3>JDK中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类<br><img src="/image/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png" alt=""></li>
</ul>
<p><strong>Exception</strong><br>所有异常类的父类，其子类对应了各种各样可能出现的异常事件。<br>Runtime Exception (unchecked Exception)</p>
<ul>
<li>一类特殊的异常，例如除以0、数组下标越界等，其产生比较频繁，处理麻烦，如果显示声明或捕获，将会对程序可读性和运行效率影响很大。因此由系统自动检测并将它们交给缺省的异常处理程序（用户可不必对其处理）。<br>Checked Exception</li>
<li>这一类异常，我们必须捕获进行处理。</li>
</ul>
<p><strong>Runtime Exception</strong><br>    // ArithmeticException 如试图除以0<br>        int b = 1;<br>        if (b!=0) {<br>        int c = 1 / b;<br>        } else {<br>        System.out.println(“不能用0做除数”);<br>        }<br>    // NullPointerException 当程序访问一个空对象的成员变量或方法时发生异常，怎么处理？<br>        TestException te = new TestException();<br>        if (te!=null) {<br>        te.test1();<br>        }else {<br>        System.out.println(“空指针异常”);<br>        }<br>    // ArrayIndexOutOfBoundsException<br>        int[] a = {1, 2, 3};<br>        int index = 3;<br>        if (index &lt;= a.length-1) {<br>        System.out.println(a[index]);<br>        }<br>    // ClassCaseException   // 类型转化异常<br>        void test2(Object object) {<br>        if (object instanceof TestException) {<br>        TestException te = (TestException) object;<br>        }<br>        }</p>
<h3 id="异常的处理方法"><a href="#异常的处理方法" class="headerlink" title="异常的处理方法"></a>异常的处理方法</h3><ol>
<li>捕获异常(try, catch, finally)<br><img src="/image/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/tryCatch" alt=""><br><strong>try</strong><br>try语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，在任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理。<br><strong>注：当异常处理的代码执行结束以后，是不会再回到try语句中去执行尚未执行的代码的。</strong><br><strong>catch</strong><br>catch捕获异常时的捕获顺序：</li>
</ol>
<ul>
<li>如果异常类之间有继承关系，在顺序安排上需注意，越是顶层的类，越放在下面。再不然就直接把多余的catch省略掉。<br><strong>finally</strong><br>有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally语句块中。<br>通常在finally中关闭程序块已打开的资源，比如：文件流、释放数据库连接等。</li>
</ul>
<ol>
<li>声明异常：throws子句<br>方法重写中声明异常原则：<br><strong>子类声明的异常范围不能超过父类声明的范围。</strong></li>
</ol>
<ul>
<li>父类没有声明异常，子类也不能。</li>
<li>不可抛出原有方法抛出异常类的父类或上层类。</li>
<li>抛出的异常类型的数目不可以比原有的方法抛出的还多（不是指个数）</li>
</ul>
<ol>
<li>自定义异常<br><strong>使用异常机制建议</strong><br>要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。<br>处理异常不可以代替简单测试— 只在异常情况下使用异常机制<br>不要进行小粒度的异常处理—应该将整个任务包装在一个Try语句块中<br>异常往往在高层处理<br><strong>总结</strong></li>
<li>一个图</li>
<li>五个关键字（try, catch, finally, throws, throw）</li>
<li>先逮小的，再逮大的</li>
<li>异常与重写的关系</li>
<li>自定义异常</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件程序在运行过程中，非常可能遇到异常问题，我们叫异常，英文是：Exception，意思是例外。这些例外情况，或者叫异常，怎么让我们写的程序做出合理的处理，而不至于程序崩溃。&lt;br&gt;常见的异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户输入错误&lt;/li&gt;
&lt;li&gt;设备错误&lt;/li&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动装箱和拆箱</title>
    <link href="http://yoursite.com/2017/06/02/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2017/06/02/自动装箱和拆箱/</id>
    <published>2017-06-02T09:29:57.000Z</published>
    <updated>2017-06-02T09:51:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>JDK5.0之后有了自动装箱，通过编译器帮我们改进代码。<br><strong>自动装箱</strong></p>
<ul>
<li>基本数据类型就自动地封装到与它相同类型的包装类中，如：</li>
<li>Integer i = 100;</li>
<li>本质上是，编译器编译时为我们添加了：</li>
<li>Integer i = new Integer(100);<br><strong>自动拆箱</strong></li>
<li>包装类对象自动转换成基本数据类型。 如：</li>
<li>int a = new Integer(100);</li>
<li>本质上，编译器编译时为我们添加了：</li>
<li>int a = new Integer(100).intValue();</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK5.0之后有了自动装箱，通过编译器帮我们改进代码。&lt;br&gt;&lt;strong&gt;自动装箱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本数据类型就自动地封装到与它相同类型的包装类中，如：&lt;/li&gt;
&lt;li&gt;Integer i = 100;&lt;/li&gt;
&lt;li&gt;本质上是，编译
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java常用类</title>
    <link href="http://yoursite.com/2017/06/01/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/06/01/Java常用类/</id>
    <published>2017-06-01T12:59:33.000Z</published>
    <updated>2017-06-05T08:03:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>基本数据类型的包装类</p>
<h3 id="字符串相关类："><a href="#字符串相关类：" class="headerlink" title="字符串相关类："></a>字符串相关类：</h3><ul>
<li>不可变字符串序列：String</li>
<li>可变字符串序列：StringBuilder、StringBuffer<h3 id="时间处理相关类："><a href="#时间处理相关类：" class="headerlink" title="时间处理相关类："></a>时间处理相关类：</h3></li>
<li>Date</li>
<li>DateFormat、SimpleDateFormat</li>
<li>Calendar、GregorianCalendar<br><img src="/image/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%B1%BB.png" alt=""><br><strong>Date时间类(java.util.Date)</strong></li>
<li>标准Java类库中包含一个Date类，它的对象表示一个特定的瞬间，精确到毫秒。</li>
<li>Java中时间的表示说白了也是数字，是从：标准纪元1970.1.1 0点到某个时刻的毫秒数，类型是long。<br><strong>DateFormat和SimpleDateFormat(java.text.DateFormat)</strong> </li>
<li>作用：完成字符串和时间对象的转化！</li>
<li>Format和parse<br><strong>Calendar和GregorianCalendar(java.util)</strong></li>
<li>人类对于时间的认识是：某年某月某日这样的日期概念。计算机是long类型的数字，通过Calendar在二者之间搭起桥梁！</li>
<li>GregorianCalendar是Calendar的一个具体子类，提供了世界上大多数国家/地区使用的标准日历系统。</li>
<li><strong>注意：</strong><ul>
<li>月份：一月是0，二月是1，以此类推，12月是11</li>
<li>星期：周日是1，周一是2，。。。。。周六是7</li>
</ul>
</li>
</ul>
<h3 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h3><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>File类(java.io.File)：</strong></p>
<ul>
<li>文件和目标路径名的抽象表示形式</li>
<li>通过File对象可以访问文件的属性<pre><code>public boolean canRead()        public boolean canWrite()
    public boolean exists()             public boolean isDirectory()
    public boolean isFile()              public boolean isHidden()
    public long lastModified()        public long length()
    public String getName()           public String getPath()
</code></pre></li>
<li>通过File对象创建空文件或目录（在该对象所指的文件或目录不存在的情况下）<pre><code>public boolean createNewFile()throws IOException
    public boolean delete()
    public boolean mkdir(),   mkdirs()   // 注意两个的区别！
</code></pre></li>
</ul>
<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><h3 id="包装类-Wrapper-Class-："><a href="#包装类-Wrapper-Class-：" class="headerlink" title="包装类(Wrapper Class)："></a>包装类(Wrapper Class)：</h3><p>将基本数据类型转化为对象</p>
<ul>
<li>byte -> Byte</li>
<li>boolean -> Boolean</li>
<li>short -> Short</li>
<li>char -> Character</li>
<li>int -> Integer</li>
<li>long -> Long</li>
<li>float -> Float</li>
<li>double -> Double<br><strong>自动装箱</strong></li>
<li>基本数据类型就自动地封装到与它相同类型的包装类中，如：</li>
<li>Integer i = 100;</li>
<li>本质上是，编译器编译时为我们添加了：</li>
<li>Integer i = new Integer(100);<br><strong>自动拆箱</strong></li>
<li>包装类对象自动转换成基本数据类型。 如：</li>
<li>int a = new Integer(100);</li>
<li>本质上，编译器编译时为我们添加了：</li>
<li>int a = new Integer(100).intValue();<br>JDK5.0之后有了自动装箱，通过编译器帮我们改进代码。</li>
</ul>
<p>你今后人生的艰难，恰恰不是因为你没能考上一个满意的学校，而是在这所学校里，在一个能让自己自由充分成长的黄金四年里，把自己给荒废了。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基本数据类型的包装类&lt;/p&gt;
&lt;h3 id=&quot;字符串相关类：&quot;&gt;&lt;a href=&quot;#字符串相关类：&quot; class=&quot;headerlink&quot; title=&quot;字符串相关类：&quot;&gt;&lt;/a&gt;字符串相关类：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不可变字符串序列：String&lt;/li&gt;
&lt;li&gt;可
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="http://yoursite.com/2017/05/28/String%E7%B1%BB/"/>
    <id>http://yoursite.com/2017/05/28/String类/</id>
    <published>2017-05-28T11:53:03.000Z</published>
    <updated>2017-05-31T04:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p>Java字符串就是<strong>Unicode</strong>字符序列，例如字符串 “Java” 就是4个Unicode字符J,a,v,a组成的。<br>Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义的类String，每个用双引号括起来的字符串都是String类的一个实例。</p>
<p><strong>String类是不可变字符串序列。</strong><br><strong>StringBuilder和StringBuffer是可变字符串序列</strong><br><strong>StringBuilder和StringBuffer的区别：</strong></p>
<ul>
<li>StringBuilder (线程不安全，效率高)</li>
<li>StringBuffer是(线程安全，效率低)。<br>之后会写一写String类的源码分析，其实也没什么可写的，源码的注释写的很清楚，可以试试把源码粘出来，自己修改看看会有什么样的效果。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串的使用&quot;&gt;&lt;a href=&quot;#字符串的使用&quot; class=&quot;headerlink&quot; title=&quot;字符串的使用&quot;&gt;&lt;/a&gt;字符串的使用&lt;/h3&gt;&lt;p&gt;Java字符串就是&lt;strong&gt;Unicode&lt;/strong&gt;字符序列，例如字符串 “Java” 就是4
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java集合类(String)" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E7%B1%BB-String/"/>
    
  </entry>
  
  <entry>
    <title>Java数组(Array)</title>
    <link href="http://yoursite.com/2017/05/28/Java%E6%95%B0%E7%BB%84-Array/"/>
    <id>http://yoursite.com/2017/05/28/Java数组-Array/</id>
    <published>2017-05-28T08:31:51.000Z</published>
    <updated>2017-05-31T04:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h3><ul>
<li><strong>数组是相同类型数据的有序集合</strong><br> 数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们，数组元素相当于对象的成员变量.</li>
<li>数组的特点：<ol>
<li>其长度是确定的。数组一旦被创建，它的大小是不可以改变的。</li>
<li>其元素必须是相同类型，不允许出现混合类型。</li>
<li>数组中的元素可以是任意数据类型，包括基本数据类型和引用类型</li>
<li>数组索引从0开始。</li>
<li>数组属于引用类型<ul>
<li>Members: length, elements of the array<h3 id="一维数组的声明"><a href="#一维数组的声明" class="headerlink" title="一维数组的声明"></a>一维数组的声明</h3><strong>一维数组的声明方式</strong>有两种：</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol>
<li><code>type[] arr_name;</code></li>
<li><code>type arr_name[];</code><br><strong>例如：</strong><br> int[] intArrays;    int intArrays[];<br> double[] doubleArrays;<br> Person[] pArrays;<br> String[] strArrays;</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组概述&quot;&gt;&lt;a href=&quot;#数组概述&quot; class=&quot;headerlink&quot; title=&quot;数组概述&quot;&gt;&lt;/a&gt;数组概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组是相同类型数据的有序集合&lt;/strong&gt;&lt;br&gt; 数组描述的是相同类型的若干个数据，按照一
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java集合类(Array)" scheme="http://yoursite.com/tags/Java%E9%9B%86%E5%90%88%E7%B1%BB-Array/"/>
    
  </entry>
  
  <entry>
    <title>接口(interface)</title>
    <link href="http://yoursite.com/2017/05/26/%E6%8E%A5%E5%8F%A3-interface/"/>
    <id>http://yoursite.com/2017/05/26/接口-interface/</id>
    <published>2017-05-26T13:27:18.000Z</published>
    <updated>2017-05-31T04:07:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>为什么需要接口？接口和抽象类的区别？</p>
<ul>
<li>接口就是比 “抽象类” 还 “抽象” 的 “抽象类”，可以更加规范的对子类进行约束。<strong>全面的专业的实现了：规范和具体实现的分离。</strong></li>
<li><strong>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。</strong>(如果你是天使，则必须能飞。如果你是汽车，则必须能跑。)</li>
<li><strong>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</strong></li>
<li><strong>项目的具体需求是多变的，我们必须以不变应万变才能从容开发，此处的 “不变” 就是 “规范”。因此，我们开发项目往往都是面向接口编程！</strong><br><strong>如何定义接口？</strong></li>
<li>格式：<pre><code>[访问修饰符] interface 接口名 [extends 父接口1， 父接口2...] {
   常量定义    // 总是public static final
   方法定义    // 总是public, abstract
}
</code></pre>子类通过implements来实现接口中的规范<br>接口不能创建实例，但是可用于声明引用变量类型。<br>一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。<br><strong>接口支持多继承</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么需要接口？接口和抽象类的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口就是比 “抽象类” 还 “抽象” 的 “抽象类”，可以更加规范的对子类进行约束。&lt;strong&gt;全面的专业的实现了：规范和具体实现的分离。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口就是规范，
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>抽象类和抽象方法</title>
    <link href="http://yoursite.com/2017/05/26/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/26/抽象类和抽象方法/</id>
    <published>2017-05-26T10:46:28.000Z</published>
    <updated>2017-05-31T08:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么需要抽象类？如何定义抽象类？"><a href="#为什么需要抽象类？如何定义抽象类？" class="headerlink" title="为什么需要抽象类？如何定义抽象类？"></a>为什么需要抽象类？如何定义抽象类？</h4><ul>
<li>抽象类是一种_模板模式。抽象类为所有子类提供了一个通用模板，子类可以在这个模板的基础上进行扩展。_</li>
<li><strong>通过抽象类，可以避免子类设计的随意性。</strong>通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用。<h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4></li>
</ul>
<ol>
<li>有抽象方法的类只能定义抽象类</li>
<li>抽象类不能实例化，及不能用new来实例化抽象类。</li>
<li>抽象类可以包含属性、方法、构造方法。但是构造方法不能用new来实例，只能用来被子类调用。</li>
<li>抽象类只能用来继承。</li>
<li>抽象方法必须被子类实现。</li>
</ol>
<p><strong>抽象方法简单说就是 只有方法声明，没有方法实现，将方法的设计和方法的实现分离了。 代码如下：</strong><br>    public abstract class Animal() {   // 抽象类<br>       public abstract void run();   // 抽象方法<br>    }</p>
<pre><code>class Cat extends Animal {
   @Override
   public void run() {
    System.out.println(&quot;猫咪跑&quot;)
   }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么需要抽象类？如何定义抽象类？&quot;&gt;&lt;a href=&quot;#为什么需要抽象类？如何定义抽象类？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要抽象类？如何定义抽象类？&quot;&gt;&lt;/a&gt;为什么需要抽象类？如何定义抽象类？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;抽象类是
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>多态(polymorphism)</title>
    <link href="http://yoursite.com/2017/05/25/%E5%A4%9A%E6%80%81-polymorphism/"/>
    <id>http://yoursite.com/2017/05/25/多态-polymorphism/</id>
    <published>2017-05-25T10:38:30.000Z</published>
    <updated>2017-05-31T04:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>多态是OOP中的一个重要特性，主要是用来实现动态联编的；换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。<br><em>Java中如何实现多态？使用多态的好处？</em></p>
<ul>
<li>引用变量的两种类型：<ul>
<li>编译时类型（模糊一点，一般是一个父类）<ul>
<li>由声明时的类型决定。<ul>
<li>运行时类型（运行时，具体是哪个子类就是哪个子类）</li>
<li>由实际对应的对象类型决定。<br>多态的存在要有3个必要条件：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li>要有继承。</li>
<li>要有方法重写。</li>
<li>父类引用指向子类对象。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态是OOP中的一个重要特性，主要是用来实现动态联编的；换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就决定了。这对于大型系统来说能提高系统的灵活性和扩展性。&lt;br&gt;&lt;em&gt;Java中如何实现多态？使用多态的好处？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>隐藏/封装(encapsulation)</title>
    <link href="http://yoursite.com/2017/05/25/%E9%9A%90%E8%97%8F-%E5%B0%81%E8%A3%85-encapsulation/"/>
    <id>http://yoursite.com/2017/05/25/隐藏-封装-encapsulation/</id>
    <published>2017-05-25T09:23:48.000Z</published>
    <updated>2017-05-31T04:07:47.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么需要封装？封装的作用和含义？"><a href="#为什么需要封装？封装的作用和含义？" class="headerlink" title="为什么需要封装？封装的作用和含义？"></a>为什么需要封装？封装的作用和含义？</h4><ul>
<li>我要看电视，只需要按一下开关和换台就可以了。有必要了解电视机内部的结构吗？有必要碰碰显像管吗？</li>
<li>我要开车，有必要知道汽车的内部是怎么构造的吗？</li>
</ul>
<p><strong>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。</strong></p>
<h4 id="我们程序设计要追求“高内聚，低耦合”。"><a href="#我们程序设计要追求“高内聚，低耦合”。" class="headerlink" title="我们程序设计要追求“高内聚，低耦合”。"></a>我们程序设计要追求“高内聚，低耦合”。</h4><ul>
<li>高内聚就是类的内部数据操作细节自己完成，不允许外部干涉。</li>
<li>低耦合就是仅暴露少量的方法给外部使用。<h4 id="使用访问控制符，实现封装"><a href="#使用访问控制符，实现封装" class="headerlink" title="使用访问控制符，实现封装"></a>使用访问控制符，实现封装</h4><img src="/image/%E5%B0%81%E8%A3%85/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E7%AC%A6.png" alt=""><br><strong>封装要点：</strong></li>
<li>类的属性的处理：<ol>
<li>一般使用private. （除非本属性确定会让子类继承）<ol>
<li>提供相应的get/set方法来访问相关属性，这些方法通常是public，从而提供对属性的读取操作。 （注意：boolean变量的get方法是用：is开头！）</li>
</ol>
</li>
</ol>
</li>
<li>一些只用于本类的辅助性方法可以用private。<br><strong>希望其他类调用的方法用public</strong></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;为什么需要封装？封装的作用和含义？&quot;&gt;&lt;a href=&quot;#为什么需要封装？封装的作用和含义？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要封装？封装的作用和含义？&quot;&gt;&lt;/a&gt;为什么需要封装？封装的作用和含义？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;我要看电
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>final关键字</title>
    <link href="http://yoursite.com/2017/05/25/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/05/25/final关键字/</id>
    <published>2017-05-25T07:59:15.000Z</published>
    <updated>2017-05-31T04:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>修饰变量：</strong></p>
<ul>
<li>作用：把一个变量修饰为常量<br><strong>修饰方法</strong></li>
<li>作用：该方法不可被子类重写，但是可以被重载<br><strong>修饰类</strong></li>
<li>作用：修饰的类不能有子类，不能被继承。比如：Math、String.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;修饰变量：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：把一个变量修饰为常量&lt;br&gt;&lt;strong&gt;修饰方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;作用：该方法不可被子类重写，但是可以被重载&lt;br&gt;&lt;strong&gt;修饰类&lt;/strong&gt;&lt;/li&gt;
&lt;l
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Object类和super关键字</title>
    <link href="http://yoursite.com/2017/05/23/Object%E7%B1%BB%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/05/23/Object类和super关键字/</id>
    <published>2017-05-23T09:20:10.000Z</published>
    <updated>2017-05-31T04:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>Object类是所有Java类的根基类。<br>如果在类的声明中未使用extends关键字指明基类，则默认基类为Object类<br>重写：toString方法：</p>
<ul>
<li>默认返回：包名+类名+@+哈希码（根据对象内存位置生成，唯一不重复）<h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4>super是直接父类对象的引用。可以通过super来访问父类中被子类覆盖（重写）的方法或属性。<br>普通方法：</li>
<li>没有顺序限制。可以随便调用<br>构造函数中：</li>
<li>任何类的构造函数中，若是构造函数的第一行代码没有显式的调用super(…); 那么Java默认都会调用super(); 作为父类的初始化函数。所以你这里的super();加不加都无所谓。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Object类&quot;&gt;&lt;a href=&quot;#Object类&quot; class=&quot;headerlink&quot; title=&quot;Object类&quot;&gt;&lt;/a&gt;Object类&lt;/h4&gt;&lt;p&gt;Object类是所有Java类的根基类。&lt;br&gt;如果在类的声明中未使用extends关键字指明基类，
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://yoursite.com/2017/05/22/%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/05/22/继承/</id>
    <published>2017-05-22T10:33:27.000Z</published>
    <updated>2017-05-31T04:07:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><ul>
<li>继承</li>
<li>封装/隐藏</li>
<li>多态<br>为了适应需求的多种变化，使代码变得更加通用！</li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol>
<li>类是对对象的抽象，继承是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li>提高代码的复用性！</li>
<li>extends的意思是 “扩展”。子类是父类的扩展<br><strong>小结</strong></li>
<li>子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法）。</li>
<li>Java中类只有单继承，没有像C++那样的多继承。多继承会引起混乱，使得继承链过于复杂，系统难以维护。就像我们现实中，如果你有多个父亲，那是一个多么混乱的世界啊。多继承，就是为了实现代码的复用性，却引入了复杂性，使得系统类之间的关系混乱。</li>
<li>Java中的多继承，可以通过接口来实现</li>
<li>如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object</li>
<li>不同的叫法：超类、父类、基类、子类、派生类<h4 id="继承方法的重写（override）"><a href="#继承方法的重写（override）" class="headerlink" title="继承方法的重写（override）"></a>继承方法的重写（override）</h4></li>
<li>在子类中可以根据需要对从父类中继承来的方法进行重写。</li>
<li>重写方法必须和被重写方法具有<strong>相同方法名称、参数列表</strong>和<strong>返回类型</strong>。</li>
<li>重写方法不能使用比重写方法更严格的访问权限。（由于多态）<h4 id="组合VS继承"><a href="#组合VS继承" class="headerlink" title="组合VS继承"></a>组合VS继承</h4><strong>“is-a” 关系使用继承！</strong><br><strong>“has-a” 关系使用继承</strong><br>最生动的比方：<br><strong> 继承是说“我父亲在家里给我帮了很大的忙”。</strong><br><strong> 组合是说“我请了个老头在我家里干活”。</strong><br><strong>区别：</strong>使用组合可以用到另一个类中私有的变量和方法，而继承就不可以用到父类的 私有的变量和方法了<br>他们都有各自的好处，要灵活的运用。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面向对象三大特征&quot;&gt;&lt;a href=&quot;#面向对象三大特征&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特征&quot;&gt;&lt;/a&gt;面向对象三大特征&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;封装/隐藏&lt;/li&gt;
&lt;li&gt;多态&lt;br&gt;为了适应需求的
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>static关键字和this关键字</title>
    <link href="http://yoursite.com/2017/05/21/static%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/05/21/static关键字和this关键字/</id>
    <published>2017-05-21T09:01:53.000Z</published>
    <updated>2017-05-31T04:07:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p><strong>在类中，用static声明的成员变量为静态成员变量，或者叫做：类属性，类变量。</strong></p>
<ul>
<li>它为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显示初始化。</li>
<li>对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享！</li>
<li>可以使用 ”对象.类属性“ 来调用。不过，一般都是用 ”类名.类属性“ 调用。</li>
<li>static变量置于方法区中！<br><strong>用static声明的方法为静态方法</strong></li>
<li>不需要对象，就可以调用（类名.方法名）</li>
<li>在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。</li>
</ul>
<p><strong>类只能使用类的方法，对象既能使用类的方法也能使用自己的方法。</strong></p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>普通方法中，this总是指向调用该方法的对象。<br>构造方法中，this总是指向正要初始化的对象。<br>this不能用于static方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;static关键字&quot;&gt;&lt;a href=&quot;#static关键字&quot; class=&quot;headerlink&quot; title=&quot;static关键字&quot;&gt;&lt;/a&gt;static关键字&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;在类中，用static声明的成员变量为静态成员变量，或者叫做：类属性
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>构造方法</title>
    <link href="http://yoursite.com/2017/05/20/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/05/20/构造方法/</id>
    <published>2017-05-20T09:40:36.000Z</published>
    <updated>2017-05-31T04:07:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>构造方法 又称为 构造器(constructor)<br>构造器用于构造该类的实例(object)<br>格式如下：</p>
<ul>
<li>【修饰符】类名 （形参列表）{<pre><code>// n条语句
</code></pre>   }<br>构造方法是一种特殊的方法：</li>
</ul>
<ol>
<li>通过new关键字调用！！</li>
<li>构造器虽然有返回值，但是不能定义返回类型（返回值的类型肯定是本类），不能在构造器里调用return</li>
<li>如果我们没有定义构造器，则系统会自动定义一个无参的构造函数。如果已定义则编译器不会添加！</li>
<li>构造器的方法名必须和类名一致！</li>
<li>作用：构造该类的对象，经常也用来初始化对象的属性。 <h3 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h3>方法的重载是指一个类中可以定义有相同名字，但参数不同的多个方法。调用时，会根据不同的参数表选择对应的方法。<br>两同三不同</li>
<li>同一个类，同一个方法名</li>
<li>不同：参数列表不同（类型，个数，顺序不同）<br>只有返回值不同不构成方法的重载（<br>int a(String str) {};<br>void a(String i),<br>调用 :a();<br>谁能告诉我是调用哪个方法？）<br>只有形参的名称不同，不构成方法的重载<br>与普通方法一样，构造方法也可以重载</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;构造方法 又称为 构造器(constructor)&lt;br&gt;构造器用于构造该类的实例(object)&lt;br&gt;格式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【修饰符】类名 （形参列表）{&lt;pre&gt;&lt;code&gt;// n条语句
&lt;/code&gt;&lt;/pre&gt;   }&lt;br&gt;构造方法是一种特殊的
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="http://yoursite.com/2017/05/20/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2017/05/20/垃圾回收机制/</id>
    <published>2017-05-20T09:07:42.000Z</published>
    <updated>2017-05-31T04:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>对象空间的分配：</strong></p>
<ul>
<li>使用new关键字创建对象即可<br><strong>对象空间的释放：</strong></li>
<li>将对象赋值null即可。垃圾回收器负责回收所有“不可达”对象的内存空间<br><strong>要点：</strong></li>
<li>程序员无权调用垃圾回收器。</li>
<li>程序员可以通过System,gc()。通知GC运行，但是Java规范并不能保证立刻运行。</li>
<li>finalize方法，是Java提供给程序员用来释放对象或资源的方法，但是尽量少用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;对象空间的分配：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用new关键字创建对象即可&lt;br&gt;&lt;strong&gt;对象空间的释放：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;将对象赋值null即可。垃圾回收器负责回收所有“不可达”对象的内存空间&lt;br&gt;&lt;stron
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>对象和类的概念</title>
    <link href="http://yoursite.com/2017/05/17/%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/05/17/对象和类的概念/</id>
    <published>2017-05-17T09:39:08.000Z</published>
    <updated>2017-05-31T04:07:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象（OOP）的本质："><a href="#面向对象（OOP）的本质：" class="headerlink" title="面向对象（OOP）的本质："></a>面向对象（OOP）的本质：</h3><ul>
<li><strong>以类的方式组织代码，以对象的方式组织（封装）数据</strong></li>
<li>面向对象思维：OOA，OOD</li>
<li>对象：是具体的事物</li>
<li>类：是对对象的抽象（抽象，抽出像的部分）先有具体的对象，然后抽象各个对象之间像的部分，归纳出类，通过类再认识其他对象</li>
</ul>
<h3 id="对象和类的关系：特殊到一般，具体到抽象"><a href="#对象和类的关系：特殊到一般，具体到抽象" class="headerlink" title="对象和类的关系：特殊到一般，具体到抽象"></a>对象和类的关系：特殊到一般，具体到抽象</h3><ul>
<li>类：我们叫做class</li>
<li>对象：我们叫做Object，instance(实例)。以后我们说某个类的对象，某个类的实例，是一样的意思。</li>
<li>类可以看成一类对象的模板，对象可以看成该类的一个具体实例</li>
<li>类是用于描述同一类型的对象的一个抽象的概念，类中定义了这一类对象所具有的静态和动态属性</li>
<li>对象是Java程序的核心，在Java程序中 “万事万物皆对象”。</li>
<li>JDK提供了很多类供编程人员使用，编程人员也能定义自己的类。</li>
</ul>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ul>
<li>Java语言中除基本类型之外的变量类型都称之为引用类型。</li>
<li>Java中的对象是通过引用reference对其操作的</li>
</ul>
<h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><ul>
<li>属性 field，或者叫成员变量</li>
<li>属性用于定义该类或该类对象包含的数据或者说静态属性</li>
<li>属性作用范围是整个类体</li>
<li>在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认的值对其初始化。（数值:0,0.0  char:\u0000,  boolean:false,  所有引用类型:null）</li>
<li>属性定义格式：<ul>
<li>【修饰符】 属性类型  属性名  =  【默认值】<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3></li>
</ul>
</li>
<li>面向对象中，整个程序的基本单位是类，方法是从属于类的</li>
<li>方法定义格式：<ul>
<li>【修饰符】方法返回值类型  方法名(形参列表) {<br> // n条语句<br> }</li>
</ul>
</li>
<li>Java中方法参数传递是：<strong>值传递！</strong><h3 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h3></li>
<li>栈：（自动分配连续的空间，后进先出）<ul>
<li>存放：局部变量</li>
</ul>
</li>
<li>堆：（不连续）<ul>
<li>存放：new出来的对象</li>
</ul>
</li>
<li>方法区：<ul>
<li>存放：类的信息（代码）、static变量、常量池（字符串常量）等。w</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面向对象（OOP）的本质：&quot;&gt;&lt;a href=&quot;#面向对象（OOP）的本质：&quot; class=&quot;headerlink&quot; title=&quot;面向对象（OOP）的本质：&quot;&gt;&lt;/a&gt;面向对象（OOP）的本质：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;以类的方式组织代码，以对
    
    </summary>
    
      <category term="Java学习笔记" scheme="http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="面向对象" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text常用快捷键</title>
    <link href="http://yoursite.com/2017/05/07/SublimeText%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2017/05/07/SublimeText常用快捷键/</id>
    <published>2017-05-07T13:09:48.000Z</published>
    <updated>2017-05-07T13:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>⌘：command <br><br>⌃：control <br><br>⌥：option <br><br>⇧：shift <br><br>↩：enter <br><br>⌫：delete <br></p>
<h4 id="打开-关闭-前往-快捷键-功能"><a href="#打开-关闭-前往-快捷键-功能" class="headerlink" title="(打开/关闭/前往)快捷键 功能"></a>(打开/关闭/前往)快捷键 功能</h4><p>⌘⇧N 打开一个新的sublime窗口 <br><br>⌘N 新建文件 <br><br>⌘⇧W 关闭sublime，关闭所有文件 <br><br>⌘W 关闭当前文件 <br><br>⌘P 跳转、前往文件、前往项目、命令提示、前往method等等（Goto anything） <br><br>⌘⇧T 重新打开最近关闭的文件 <br><br>⌘T 前往文件 <br><br>⌘⌃P 前往项目 <br><br>⌘R 前往method <br><br>⌘⇧P 命令提示 <br><br>⌃G 前往行 <br><br>⌘KB 开关侧栏 <br><br>⌃` 打开控制台 <br><br>⌃- 光标跳回上一个位置 <br><br>⌃⇧- 光标恢复位置<br></p>
<h4 id="编辑-快捷键-功能"><a href="#编辑-快捷键-功能" class="headerlink" title="(编辑)快捷键 功能"></a>(编辑)快捷键 功能</h4><p>⌘A 全选 <br><br>⌘L 选择行（重复按下将下一行加入选择） <br><br>⌘D 选择词（重复按下时多重选择相同的词进行多重编辑） <br><br>⌃⇧M 选择括号的内容 <br><br>⌘⇧↩ 在当前行前插入新行 <br><br>⌘↩ 在当前行后插入新行 <br><br>⌃⇧K 删除行 <br><br>⌘KK 从光标处删除至行尾 <br><br>⌘K⌫ 从光标处删除至行首 <br><br>⌘⇧D 复制（多）行 <br><br>⌘J 合并（多）行 <br><br>⌘KU 改为大写 <br><br>⌘KL 改为小写 <br><br>⌘C 复制 <br><br>⌘X 剪切 <br><br>⌘V 粘贴 <br><br>⌘/ 注释 <br><br>⌘⌥/ 块注释 <br><br>⌘Z 撤销 <br><br>⌘Y 恢复撤销 <br><br>⌘⇧V 粘贴并自动缩进 <br><br>⌘⌥V 从历史中选择粘贴 <br><br>⌃M 跳转至对应的括号 <br><br>⌘U 软撤销（可撤销光标移动） <br><br>⌘⇧U 软重做（可重做光标移动） <br><br>⌘⇧S 保存所有文件 <br><br>⌘] 向右缩进 <br><br>⌘[ 向左缩进 <br><br>⌘⌥T 特殊符号集 <br><br>⌘⇧L 将选区转换成多个单行选区<br></p>
<h4 id="查找-替换-快捷键-功能"><a href="#查找-替换-快捷键-功能" class="headerlink" title="(查找/替换)快捷键 功能"></a>(查找/替换)快捷键 功能</h4><p>⌘f 查找 <br><br>⌘⌥f 查找并替换 <br><br>⌘⌥g 查找下一个符合当前所选的内容 <br><br>⌘⌃g 查找所有符合当前选择的内容进行多重编辑 <br><br>⌘⇧F 在所有打开的文件中进行查找<br></p>
<h4 id="拆分窗口-标签页-快捷键-功能"><a href="#拆分窗口-标签页-快捷键-功能" class="headerlink" title="(拆分窗口/标签页)快捷键 功能"></a>(拆分窗口/标签页)快捷键 功能</h4><p>⌘⌥[1,2,3,4] 单列、双列、三列、四列<br>⌘⌥5 网格（4组） <br><br>⌃[1,2,3,4] 焦点移动到相应的组（分屏编号） <br><br>⌃⇧[1,2,3,4] 将当前文件移动到相应的组（分屏编号） <br><br>⌘[1,2,3,4] 选择相应的标签页<br></p>
<h4 id="快捷操作-快捷键-功能"><a href="#快捷操作-快捷键-功能" class="headerlink" title="(快捷操作)快捷键 功能"></a>(快捷操作)快捷键 功能</h4><p>⌘⌃ 上下键 两行交换位置 <br><br>⌘KB  显示/隐藏侧边<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;⌘：command &lt;br&gt;&lt;br&gt;⌃：control &lt;br&gt;&lt;br&gt;⌥：option &lt;br&gt;&lt;br&gt;⇧：shift &lt;br&gt;&lt;br&gt;↩：enter &lt;br&gt;&lt;br&gt;⌫：delete &lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;打开-关闭-前往-快捷键-功能&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
    
      <category term="Sublime Text" scheme="http://yoursite.com/tags/Sublime-Text/"/>
    
  </entry>
  
  <entry>
    <title>我希望进入大学时就能知道的一些事（转）</title>
    <link href="http://yoursite.com/2017/03/07/%E6%88%91%E5%B8%8C%E6%9C%9B%E8%BF%9B%E5%85%A5%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%B0%B1%E8%83%BD%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2017/03/07/我希望进入大学时就能知道的一些事/</id>
    <published>2017-03-07T03:41:46.000Z</published>
    <updated>2017-03-08T00:04:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>又读到一篇很好的文章，忍不住就翻译了过来。每个月我可能会读一百来篇来自英语世界的文章，其中可能有些好文会让我忍不住想翻译过来分享下，这也算是百里挑一吧。<br>下面是原文，最后我会写写我的感想。</p>
<p>这是一份我给 Berklee College of Music（伯克利音乐学院，当代最大的音乐学院，位于波士顿）一年级新生的演讲。于 2008 年 9 月 5 日。</p>
<h3 id="1-专注、离线、切勿分心"><a href="#1-专注、离线、切勿分心" class="headerlink" title="1. 专注、离线、切勿分心"></a>1. 专注、离线、切勿分心</h3><p>我最喜欢电影中关于训练的部分，年轻的布鲁斯·韦恩（蝙蝠侠），尼奥（黑客帝国）或功夫熊猫去到一个遥远的地方接受持续的训练，不断地突破超越极限，直到他们成长为大师。<br>接下来的几年将会是你的训练之旅，假如你保持专注的话。不幸的是，你不是身处西伯利亚，而是被各种干扰诱惑所围绕。你被一些酷酷的很有吸引力的人所围绕，告诉你放松一下，去悠哉的玩个尽兴。但是这些悠哉的家伙，最终只能成为平庸的人，过着庸常的生活。<br>再回头看时，我唯一个取得成就的伯克利同学，就是一个极度专注、内心坚定和从未分心的人。<br>当你在这里读书时，总统会换届，世界会改变，而媒体尝试让你相信所有这些对你很重要。但实际不是的，这些事情对你都不重要。你是在接受考验。你的敌人是分心。保持离线，关掉你的电脑，呆在你的练习棚里。<br>当你数年后再出来时，你可以问问其他人你错过了什么没有，然后你会发现你错过的事情只需要分分钟就能归纳总结出来。而其余的不过是噪音，你会为你避开它们而感到骄傲的。<br>保持专注、离线、切勿分心，这是第一点最重要的挑战。假如你掌握了专注，你将控制自己的世界，否则，世界将控制你。</p>
<h3 id="2-不要接受他们的速度限制"><a href="#2-不要接受他们的速度限制" class="headerlink" title="2. 不要接受他们的速度限制"></a>2. 不要接受他们的速度限制</h3><p>没有极端的行动，你就不会得到极端的结果。<br>伯克利的课程设置节奏，是让普通的大多数学生都能跟上。如果你想位于平均水准之上，你必须驱动自己做得比要求得更多。<br>有个关于功夫的说法：“当你不练习时，有人在练习。当你碰到他时，他就会击败你。”<br>假如你写歌，你不仅需要一周写一首歌，而且还需要花两倍的时间来边写边改进。灵感是一个好的开始，但勤奋才能让每个音符和歌词达到完美，这才能让你真正出类拔萃。<br>幸运的是，当我 17 岁时，在进入伯克利前几个月，我遇见了一个曾在伯克利教过书的名叫基默·威廉姆斯（Kimo Williams）的人，他使我相信伯克利的标准学习节奏是为傻瓜准备的。<br>在三节强化课上，他教了我伯克利和声课程三学期的内容，所以到开学时我进入伯克利直接从第四期和声课开始学习。在另一节强化课上，他教了我关于编曲第一学期的全部内容。<br>此后我明白了我可以自己买书学习一些我没有报名的课程，并且完成所有的练习范例，完全不需要去上课。我还可以和系主任接洽并参加期末考试取得学分。我曾经就是这样完成了我的编曲二期和传统的复调课程的。<br>两年半之后，我从伯克利毕业了。不要接受学校的速度限制。<br>超越他们的期望。</p>
<h3 id="3-没人会教你任何东西，你得自学"><a href="#3-没人会教你任何东西，你得自学" class="headerlink" title="3. 没人会教你任何东西，你得自学"></a>3. 没人会教你任何东西，你得自学</h3><p>当我刚到伯克利时，我很失望。老师们没有教我什么，我几乎退学。我回到了芝加哥的家里，接受了东北大学的录取。之后我发现他们（东北大学）的音乐课程更多是让你记住巴赫的许多子孙们的名字。<br>所以我又兴致勃勃的回到了伯克利。我决定压榨出这个地方每一点一滴的知识，没人会为我做这件事。别期待老师会教你。他们将在你面前展示一些信息，但这百分百取决于你要么充分利用它，要么在这儿浪费时间，然后回家找一个平庸且乏味的工作。<br>伯克利就像一个图书馆。你需要知道的一切都在这里，任你获取。这是你精通音乐最具可能性的环境，但没人会教你任何东西，你得自学。</p>
<h3 id="4-向你的偶像学习，而不仅限于向老师学"><a href="#4-向你的偶像学习，而不仅限于向老师学" class="headerlink" title="4. 向你的偶像学习，而不仅限于向老师学"></a>4. 向你的偶像学习，而不仅限于向老师学</h3><p>当我在伯克利时，期间我的目标之一是成为一名伟大的歌曲作者。伯克利的作曲课程让人惊叹。我从中学会很多关于打磨歌曲的技巧，这让我去看我最喜欢的音乐时有了全新的洞察，并永久的提升了我的写歌能力。<br>但是我记得一个词作老师说过，一首好歌词需要运用到五感。他曾说：“不要仅是提及你的奶奶，而要去描述她手背的血管。不要仅是提及一间卧室，而要去描述窗帘上灰尘的味道和脆生生的椅子的嘎吱声。”。<br>所以多年来，我认为我写的每一首歌词若非描述了五感，那就是垃圾。然而最终我注意到我最爱的来自涅槃乐队（Nirvana，一支美国的摇滚乐队）和传声头像（Talking Heads，一支美国新浪潮乐团）的歌词，都是一些抽象的让人怀旧的废话拼接。<br>我最爱的来自比约克（Björk，一位冰岛创作歌手、乐器多面手，同时也是一位音乐制作人）的有些毛刺声的电子乐，是他们永远不会在《摇滚现场编曲 I》的课上教的。所以，最终我意识到了一个在这里我错过了的重要的点，我希望你们不要忘记：老师是拿他们最喜欢的音乐来教你相应的技术。<br>学习并欣赏这些技术，它们棒极了。但是如果你仅仅学习了他们教你的这些技术，那你仅是学会了他们最喜欢的音乐类型。不要认为老师们的偶像会比你的更好。你会听许多杰出的作品，但无论你喜欢的是什么，它们对你而言都是最棒的。<br>他们将以同样的方式分解仙妮亚·唐恩（Shania Twain，加拿大女歌手和作曲家，在乡村音乐和流行音乐方面非常成功）的主打歌或者一首查理·帕克（Charlie Parker）的经典独奏，以此来教你埋藏其中的技艺。你必须学会如何分解你最爱的音乐并分析它的技巧。<br>最终，我分析了我最爱的涅槃乐队和传声头像的歌词，以及比约克音乐中的毛刺与低吼声。提炼了它们之中的元素用在了我自己的音乐中。<br>向你的偶像学习，而不仅限于向老师学。</p>
<h3 id="5-不要停留在过去"><a href="#5-不要停留在过去" class="headerlink" title="5. 不要停留在过去"></a>5. 不要停留在过去</h3><p>还在伯克利时，我感觉得学习 Donna Lee（一种旧式博普爵士乐标准）以成为一名好的音乐家。有一次我获得了一场很棒的演出机会，将和低音贝斯手维克托·贝利（Victor Bailey）去日本一个月。<br>他当时是世界上最好的贝斯手之一，曾和韦恩·肖特（Wayne Shorter，萨克斯管吹奏家），乔·查威努（Joe Zawinul，键盘手），桑尼·罗林斯（Sonny Rollins，爵士音乐家），斯汀（Sting，歌手）等等著名音乐人一起演出。<br>他听说我会演奏一点 Donna Lee，然后说到：“哥们，爵士就是要发明新的东西。对于一个 50 年后的音乐家却被困在 1950 年代，这就像一个 1950 年代的音乐家被困在了 1900 年代。这没什么酷的。”<br>几周后，我坐在钢琴前安静的创作我自己的歌，然后第一次他对我说：“嗨 —— 哇 —— 这是什么？这太棒了，哥们，能给我看看么？”<br>创新不仅仅是模仿，不要停留在过去。</p>
<h3 id="6-毕业了，当有价值"><a href="#6-毕业了，当有价值" class="headerlink" title="6. 毕业了，当有价值"></a>6. 毕业了，当有价值</h3><p>当你还在这里时，把自己锁在练习棚里吧。享受这美妙的隔离期，没有其他任何责任，仅仅需要提升自己。但当你离开这里后，冲向书店的商业区，开始一周读一本关于企业经营的书，比如市场营销。<br>永远不要低估赚钱对制作音乐的重要性。丢弃那些你曾拥有的奇怪的禁忌。金钱仅仅是你对其他人的生活创造了价值的中立证明。确保你在赚钱是确保你在做一些对其他人有价值的事。<br>记住，这通常来自于做大多数人不做的事情。例如：这个世界支付给玩电子游戏的人多少钱？几乎可以忽略不计，因为几乎每个人都在玩。那么这个世界又支付给制作电子游戏的人多少钱？数以吨计，因为很少有人能做这件事，而很多人却想要玩。<br>所以：<br>做少数足够聪明能赚到钱来制作音乐的人之一，而非假装这不重要。<br>做少数有勇气做一些令人震惊的事情的人之一。<br>做少数把这里的课程作为起点，并驱动自己做得比学到的更多的人之一。<br>做少数知道如何帮助自己，而非期待别人来帮你的人之一。<br>做少数做的远远多于要求的人之一。<br>最重要的是，当其他人在网上冲浪，在 Facebook 上调情和追剧时，做少数呆在练习棚里练习的人之一。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又读到一篇很好的文章，忍不住就翻译了过来。每个月我可能会读一百来篇来自英语世界的文章，其中可能有些好文会让我忍不住想翻译过来分享下，这也算是百里挑一吧。&lt;br&gt;下面是原文，最后我会写写我的感想。&lt;/p&gt;
&lt;p&gt;这是一份我给 Berklee College of Music（
    
    </summary>
    
      <category term="大学" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="转载" scheme="http://yoursite.com/categories/%E5%A4%A7%E5%AD%A6/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="经验" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="成长" scheme="http://yoursite.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>程序设计的基本方法</title>
    <link href="http://yoursite.com/2016/11/16/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/11/16/程序设计的基本方法/</id>
    <published>2016-11-15T21:48:15.000Z</published>
    <updated>2016-11-16T09:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IPO模式"><a href="#IPO模式" class="headerlink" title="IPO模式"></a>IPO模式</h3><ul>
<li>I：Input输入，程序的输入</li>
<li>P：Process处理，程序的主要逻辑</li>
<li>O：Output输出，程序的输出</li>
</ul>
<h3 id="理解IPO模式"><a href="#理解IPO模式" class="headerlink" title="理解IPO模式"></a>理解IPO模式</h3><ul>
<li><p>输入</p>
<ul>
<li>程序的输入包括：文件输入、网络输入、用户手工输入、随机数据输入、程序内部参数输入等</li>
<li>输入是一个程序的开始</li>
</ul>
</li>
<li><p>输出</p>
<ul>
<li>程序的输出包括：屏幕显示输出、文件输出、网络输出、操作系统内部变量输出等</li>
<li>输出是一个程序展示运算结果的方式</li>
</ul>
</li>
<li><p>处理</p>
<ul>
<li>程序对输入进行处理，输出产生结果</li>
<li>处理的方法也叫算法，是程序最重要的部分</li>
<li>算法是一个程序的灵魂</li>
</ul>
</li>
</ul>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><pre><code><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">True</span>)  a=<span class="number">1</span></div></pre></td></tr></table></figure>
</code></pre><ul>
<li>它是没有输入输出的程序</li>
<li>“死循环”也有价值，它通过不间断执行，快速消耗CPU的计算资源，可以用来测试CPU性能</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IPO模式&quot;&gt;&lt;a href=&quot;#IPO模式&quot; class=&quot;headerlink&quot; title=&quot;IPO模式&quot;&gt;&lt;/a&gt;IPO模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;I：Input输入，程序的输入&lt;/li&gt;
&lt;li&gt;P：Process处理，程序的主要逻辑&lt;/li&gt;
&lt;l
    
    </summary>
    
    
      <category term="IPO" scheme="http://yoursite.com/tags/IPO/"/>
    
  </entry>
  
  <entry>
    <title>搭建Hexo博客</title>
    <link href="http://yoursite.com/2016/10/08/%E6%90%AD%E5%BB%BAHexo/"/>
    <id>http://yoursite.com/2016/10/08/搭建Hexo/</id>
    <published>2016-10-08T03:44:56.000Z</published>
    <updated>2016-10-09T02:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>搭建博客教程:</strong> <a href="http://www.ac4fun.com/" title="http://www.ac4fun.com" target="_blank" rel="external">http://www.ac4fun.com</a><br><strong>常用命令:</strong><br>    hexo clean    : 清除public文件夹，重新部署之前的步骤<br>    hexo generate : 修改配置或者提交新文章后都需要重新部署，主要是声明public文件夹里面的内容<br>    hexo deploy   : 将更新后的的博客上传至你的github空间</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;搭建博客教程:&lt;/strong&gt; &lt;a href=&quot;http://www.ac4fun.com/&quot; title=&quot;http://www.ac4fun.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ac4fun.
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Hexo/Node-js/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
